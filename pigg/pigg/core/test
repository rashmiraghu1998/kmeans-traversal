\section{Generalized ECDSA - An aggregate scheme}
\begin{definition}
Let $E$ be an
elliptic curve defined over $\mathbb{Z}_q$ and generated by a point $\mathcal{G}$ of prime order q, and let $E^{*}$ be
the set of points $(x, y)$ on the curve excluding the point at infinity $\mathcal{O}$. Let $c \xleftarrow{\$} \mathbb{Z}_q. c$ can be assumed to be computed using a secure key exchange protocol run by all parties. Let $\lambda$ be the security parameter. Let \(\text{Hash}\) be a hash function:
            $
            \text{Hash}: \{0, 1\}^* \to \mathbb{Z}_q
            $.          Let $\mathbf{R}$ be a set of randomness.
    A Generalized ECDSA ($\Sigma_{{\text{Gen-ECDSA}}}$) with input length $n$ = $n(\lambda)$ and associated message set  $\mathcal{M} \in \{0, 1\}^n$ is a tuple of five PPT algorithms $\Sigma_{\text{Gen-ECDSA}}$ = (KeyGen$_{\text{ECDSA}}$, Sign$_{\text{Gen-ECDSA}}$, Verify$_{\text{Gen-ECDSA}}$, $\text{Aggregate}_{\text{Gen-ECDSA}}, \\\text{AggVerify}_{\text{Gen-ECDSA}}$)
    \begin{itemize}
        \item \textbf{Construction:}
\item KeyGen$_{\text{ECDSA}}(1^\lambda, \mathcal{G}) \rightarrow (pk, sk, c)$. On input the security parameter $1^\lambda$ and a point $\mathcal{G}$, run KeyGen$_{\text{ECDSA}}(1^\lambda, \mathcal{G})$ to get public key pk, secret key sk. Output $(pk, sk)$.
\item Sign$_{\text{Gen-ECDSA}}(\mathcal{G}$, $sk$, $m$, $c$) $\rightarrow \sigma_{\text{ECDSA}}$. On input the secret key $sk$ generated using $KeyGen$ and $m \in \mathcal{M}$,
\begin{itemize}
\item Let $f$ be a random oracle of the form $f: \mathbb{Z}_q \rightarrow $ defined by -
\[
f(c) = [c \cdot \mathcal{G}]_{x}
\]
The oracle performs a scalar-point multiplication and returns a normalized x-coordinate.

\item Pick $k \xleftarrow{\$} \mathbb{Z}_q$ and compute $x = f(c)$. Compute $h = \text{Hash}(m)$.
\item Consider the polynomial $y(x^k) = sk \cdot x^k + h  $. Now, construct a scaled polynomial $y'(x^k)= c^{-1} * y(x^k)$ where $c^{-1}*c=1$.
\item Output the signature $\sigma_{\text{Gen-ECDSA}} = (x, x^k, y'(x^k))$.
\end{itemize}
\item Verify$_{\text{Gen-ECDSA}}$($\mathcal{G},pk$, $m$, $\sigma_{\text{Gen-ECDSA}}$) $\rightarrow b$. On input the public key $pk$ generated using $\text{KeyGen}$, $m \in \mathcal{M}$ and signature $\sigma_{\text{Gen-ECDSA}}$ on message $m$,
\begin{itemize}
\item Compute $h = \text{Hash}(m)$.
\item Verify $x =  [((h * (y'(x^k)^{-1})\cdot \mathcal{G}) \cdot ((x^k * (y'(x^k)^{-1})) \cdot pk)]_{x}$
\end{itemize}
\item Aggregate$_{\text{Gen-ECDSA}}((pk_1, m_1, \sigma_1),\dots,(pk_n, m_n, \sigma_n)) \rightarrow \sigma_{\text{Gen-ECDSA}}$. On input a sequence of public keys $(pk_1,\dots, pk_n)$, a sequence of messages $(m_1, \dots, m_n)$ and signatures $(\sigma_1, \dots, \sigma_n)$ with $\sigma_i$ for $m_i$,
\begin{itemize}
\item Each $\sigma_i , \forall i \in [n],$ is of the form $(x, x^{k_i}, y'(x^{k_i}))$. Compute $y'(x) = \sum_{i=1}^{n} y'(x^{k_i})$. $x[\cdot] = \varnothing.$ For each $i \in [n], x'[i] = {x^k}$.
\item Output the aggregate signature $\sigma_{\text{Gen-ECDSA}} =(x, x', y'(x))$.
\end{itemize}
\item AggVerify($(pk_1,\dots, pk_n), (m_1, \dots, m_n), \sigma_{\text{Gen-ECDSA}}) \rightarrow b$.  On input a sequence of public keys $(pk_1,\dots, pk_n)$, a sequence of messages $(m_1, \dots, m_n)$ and aggregate signature $\sigma_{\text{Gen-ECDSA}}$ with $\sigma_i$ for $m_i \ \forall i\in [n]$,
\begin{itemize}
\item Compute $h_i = \text{Hash}(m_i) \forall i \in [n]$.
\item Verify $x =  [((\sum_{i=1}^{n}h_i * (y'(x)^{-1})\cdot \mathcal{G}) \cdot (\prod_{i=1}^{n}(x'[i] \cdot pk_i)\cdot (y'(x)^{-1})]_{x}$
\end{itemize}
\end{itemize}
Let us check the properties of the signature scheme $\Sigma_{\text{ECDSA}}$.
\item \textbf{Correctness}
By construction,  $(sk \cdot \mathcal{G}, sk) \leftarrow KeyGen_{\text{ECDSA}}(1^\lambda, \mathcal{G})$ is run $n$ times to obtain $n$ pairs of $(pk_1, sk_1),\dots, (pk_n, sk_n)$, $m_i$ in $\mathcal{M}$,
$\sigma_{\text{Gen-ECDSA}} \leftarrow Sign_{\text{Gen-ECDSA}}(\mathcal{G}, sk, m, c)$. $\mathcal{P}$ first picks $k \xleftarrow{\$} \mathbb{Z}_q$ and compute $x = f(c)$. Compute $h = Hash(m)$ and returns $\sigma_{i \text{Gen-ECDSA}} = (x, x^k_i, c^{-1}*(sk\cdot x^k+h))$ to the verifier. This is executed $n$ times to obtain $(pk_1, m_1, \sigma_1),\dots,(pk_n, m_n, \sigma_n)$. Now, execute Aggregate($(pk_1, m_1, \sigma_1),\dots,(pk_n, m_n, \sigma_n))$) to obtain $\sigma_{\text{Gen-ECDSA}} = ([k_1, \dots, k_n], c^{-1}*(\sum_{i=1}^{n}\text{Hash}(m_i)+\sum_{i=1}^{n}sk_ix^{k_i})$. Now, $\mathcal{V}$ first computes $h_i = \text{Hash}(m_i) \forall i \in [n]$ and then verifies by checking the equality -

\[ [((\sum_{i=1}^{n}h_i * (y'(x)^{-1})\cdot \mathcal{G}) \cdot (\prod_{i=1}^{n}(x'[i] \cdot pk_i)\cdot (y'(x)^{-1})]_{x} \]
\[= [((\sum_{i=1}^{n}h_i * (y'(x)^{-1})\cdot \mathcal{G}) \cdot (\prod_{i=1}^{n}(x'[i]\cdot (sk_i \cdot \mathcal{G}))\cdot (y'(x)^{-1})]_{x} = \]
\[ [(y'(x)^{-1})\cdot (\sum_{i=1}^{n}\text{Hash}(m_i)+\sum_{i=1}^{n}sk_ix^{k_i})\cdot \mathcal{G} ]_{x}  \]
\[ = [(c^{-1}*(\sum_{i=1}^{n}\text{Hash}(m_i)+\sum_{i=1}^{n}sk_ix^{k_i}))^{-1})\cdot (\sum_{i=1}^{n}\text{Hash}(m_i)+\sum_{i=1}^{n}sk_ix^{k_i})\cdot \mathcal{G} ]_{x} = [c \cdot G]_{x} = x\]

Verifier returns 1 by construction.
\item \textbf{Unforgeability}
Security analysis of Generalized ECDSA.
We show that Generalized ECDSA is uf-koa.
\\
First, let us define preliminaries:\\
\textbf{Defining function}
The defining function for Generalized ECDSA is ${\mathbf{E}}(y', h, x, k, c, sk)$- \[ (h+ sk \cdot x^k ) = y'\cdot c\]
Now, let us define the defining function
${\mathbf{E_{agg}}}(y', h_i, x, k_i, c,  sk_i:\forall i\in n)$ for a generalized ECDSA (aggregate) given by:
\[
(\sum_{i=1}^{n}h_i+\sum_{i=1}^{n}sk_ix^{k_i}) = y' \cdot c.
\]

\textbf{Signing function and verification function}

Let \( \mathbf{E} \) be a defining equation. Then, we define the signing function \( S_{\mathbf{E}}\) as follows:
\[S_{\mathbf{E}}(y', h, x,k, c) = S_{\mathbf{E},sk}(h, x, k,c) = \]
\[
\begin{cases}
y', & \text{if there exists a unique } y' \text{ such that } {\mathbf{E}}(y', h, x, k, c, sk) \text{ is satisfied}, \\
\bot, & \text{otherwise}.
\end{cases}
\]
Let \( \mathbf{E_{agg}} \) be a defining equation. Then, we define the signing function \( S_{\mathbf{E_{agg}}}\) as follows:
\[S_{\mathbf{E_{agg}}}(y', h_i, x,k_i, c; \forall i \in n) = S_{\mathbf{E_{agg}},sk_i}(h_i, x, k_i,c;\forall i \in n) = \]
\[
\begin{cases}
y', & \text{if there exists a unique } y' \text{ such that } {\mathbf{E_{agg}}}(y', h_i, x, k_i, c, sk_i;\forall i \in n) \text{ is satisfied}, \\
\bot, & \text{otherwise}.
\end{cases}
\]
Further, we define the verification function \( V_E \) with respect to a group generated by $\mathcal{G}$ of prime of order $q$ as:
\[
V_E(\mathcal{G}, y', h, x, k, sk) = V_{{\mathbf{E}},\mathcal{G},sk}(y', h, x, k) =
\begin{cases}
c \cdot \mathcal{G}, & \text{if } c \text{ is the (unique) solution of } {\mathbf{E}}(y', h, x, k, c, sk), \\
\bot, & \text{otherwise}.
\end{cases}
\]
Note that the affine linear form of \( {\mathbf{E}} \) makes it possible to efficiently evaluate \( V_{\mathbf{E}}\) given just \( y', h, x, k, sk \cdot \mathcal{G} \), i.e., without knowing \( sk \) explicitly.

we define the verification function \( V_{E_{agg}} \) with respect to a group generated by $\mathcal{G}$ of prime of order $q$ as:
\[
V_{E_{agg}}(\mathcal{G}, y', h_i, x, k_i, sk_i;\forall i \in n) = V_{{\mathbf{E_{agg}}},\mathcal{G},sk_i}(y', h_i, x, k_i;\forall i \in n) = \]
\[
\begin{cases}
c \cdot \mathcal{G}, & \text{if } c \text{ is the (unique) solution of } {\mathbf{E_{agg}}}(y', h_i, x, k_i, c, sk_i;\forall i \in n), \\
\bot, & \text{otherwise}.
\end{cases}
\]
Note that the affine linear form of \( {\mathbf{E_{agg}}} \) makes it possible to efficiently evaluate \( V_{\mathbf{E_{agg}}}\) given just \( \forall i \in n, y', h_i, x, k_i, sk_i \cdot \mathcal{G} \), i.e., without knowing any of the \( sk_i \) explicitly.


We now show the following -
\begin{theorem} Consider an elliptic curve $E$ defined over $\mathbb{Z}_q$ and generated using a point $\mathcal{G}$ of the prime order $q$. Let $\mathbf{E}$ be a defining equation with the corresponding set $\mathbb{D}$ for Generalized ECDSA, let $\mathbf{E_{agg}}$ be a defining equation with the corresponding set $\mathbb{D}$ for Generalized ECDSA(Aggregate signature), let Hash: \{0,1\}$^* \rightarrow \mathbb{Z}_q$ be functions. If Hash is modeled as a random oracle, if $\mathbf{E_{agg}}$ can be $h_i$ decomposed into $\rho_0, \rho_1$and if $\mathbf{E}$ can be $h$ decomposed into $\rho_0, \rho_1$, then the semi-logarithm problem in $\mathbb{E}$ with respect to $\rho_0, \rho_1$ is non-tightly equivalent to the uf-koa of Generalized ECDSA instantiated with  \((\mathbf{E}, \mathbf{E_{agg}}, E, \text{Hash}, f, \mathbb{D})\).

More precisely, for any adversary $\mathcal{A}$ that $(\tau, \varepsilon)-$ breaks SLP, there exists a forger $\mathcal{F}$ that $(\tau', \varepsilon)-$ breaks uf-koa of Generalized ECDSA where $\tau \approx \tau'$.

\begin{proof}


We, first, show that $\mathbf{E}$ is $h$-decomposable. We then proceed to show that $\mathbf{E_{agg}}$ is $h_i$ decomposable. If $\mathbf{E}$ and $\mathbf{E_{agg}}$ are $h$-decomposable and $h_i$-decomposable respectively, we show a reduction to SLP problem.

Given an adversary $\mathcal{A}$ that $(\tau, \varepsilon)-$ breaks SLP, construct a forger $\mathcal{F}$ $(\tau', \varepsilon)-$ breaks uf-koa of Generalized ECDSA for any hash function, Hash.

On input, $\mathcal{F}$ obtains set of public keys $P_n: pk_i; \forall i\in n$ and $\mathcal{G}$. It picks any message $m_i$ independent of $P_n$ such that Hash(m) $\neq 0$ and computes $h$=Hash(m), $\mathcal{G}' \leftarrow \mathcal{G}^{\eta_0}(h)$ and $pk' \leftarrow pk^{\eta_1}(h)$. Then lets $\mathcal{A}$ compute SLP as per $(u,v) \xleftarrow{\$} \mathcal{A}(\mathcal{G}', pk')$. $(u,v)$ must be a valid signature of m with respect to $\mathcal{G}$ and $pk$.

We see that $\mathbf{E}$ is decomposable such that -
\[
\hat{x} = V^{\mathbf{E}}_{\mathcal{G}, sk}(u,h,v, k) = ((\eta_0(h) \cdot \rho_0(u,v, k))\cdot \mathcal{G})((\eta_1(h) \cdot \rho_1(u,v, k)){pk}) = \]
\[
((\rho_0(u,v, k))\cdot \mathcal{G}')((\rho_1(u,v, k)){pk}')
\]

so $\hat{x} = v$. This proves that $\mathcal{F}$ can forge  individual signatures. \\

Now, given a set of $d$ signatures - $(pk_1, m_1, (u_1, v_1)), \dots, (pk_d, m_d,(u_d, v_d))$, $\mathcal{F}$ computes $h_i = \text{Hash}(m_i), \mathcal{G}' \leftarrow \mathcal{G}^{\eta_0}(h_1,\dots, h_n) \text{ and } pk' \leftarrow pk_1^{\eta_1}(h_1),\dots, pk_n^{\eta_1}(h_n)$. Then lets $\mathcal{A}$ compute SLP as per $(u', v') \xleftarrow{\$} \mathcal{A}(\mathcal{G'}, pk')$.
\\
We see that $\mathbf{E_{agg}}$ is decomposable such that -
\[
\hat{x} = V^{\mathbf{E_{agg}}}_{\mathcal{G}, sk_i}(u',h_i,v', k_i ; \forall i \in n) = \]
\[(\eta_0(h_1,\dots, h_n ) \cdot \rho_0(u',v', k_i)\cdot \mathcal{G})(\eta_1(h_1,\dots, h_n){\prod_{i=1}^{n}( pk_i)}  \cdot (\rho_1(u',v', k_i))) = \]
\[(\rho_0(u',v', k_i)\cdot \mathcal{G}')(\rho_1(u',v', k_i)\cdot pk') \]

so $\hat{x} = v'$. Hence proved that $\mathcal{F}$ can forge aggregate signatures if given access to $\mathcal{A}$ which can sucessfully break SLP assumption.
\end{proof}

With the above proof, we have shown that Generalized ECDSA is uf-koa.

Now, we show security of Generalized ECDSA against Existential Aggregate Signature Attack and Set operation Aggregate Signature Attack.


\textbf{Security of ECDSA in EC-GGM}
Before we talk about the security, we introduce definitions for hash functions.
\begin{definition}(Random-preimage resistance)                                                                                                                                                              Let \(\text{Hash}\) be a hash function whose output space is \( \mathbb{Z}_q \). Let \( \mathcal{A} \) be an adversary. We define \( \text{RPR}_{\text{adv}}[\mathcal{A}, \text{Hash}] \) to be the advantage of \( \mathcal{A} \) in breaking the random-preimage resistance of \(\text{Hash}\). This is defined as the probability that \( \mathcal{A} \) wins the following game:

\begin{itemize}
    \item The challenger chooses \( h \in \mathbb{Z}_q \) uniformly at random and gives \( h \) to \( \mathcal{A} \).
    \item \( \mathcal{A} \) outputs a message \( m \).
    \item We say \( \mathcal{A} \) wins the game if \( \text{Hash}(m) = h \).
\end{itemize}
\end{definition}

\begin{definition}(Zero-preimage resistance)
    Let \(\text{Hash}\) be a hash function whose output space is \( \mathbb{Z}_q \). Let \( \mathcal{A} \) be an adversary. We define \( \text{ZPR}_{\text{adv}}[\mathcal{A}, \text{Hash}] \) to be the advantage of \( \mathcal{A} \) in breaking the zero-preimage resistance of \(\text{Hash}\). This is defined as the probability that \( \mathcal{A} \) wins the following game:

\begin{itemize}
    \item \( \mathcal{A} \) outputs a message \( m \).
    \item We say \( \mathcal{A} \) wins the game if \( \text{Hash}(m) = 0 \).
\end{itemize}

Note that the probability of winning in this game is taken over the random choices of \( \mathcal{A} \) as well as any random choices made in generating system parameters that define \(\text{Hash}\).
\end{definition}

\begin{definition} (Collision resistance)
    Let \(\text{Hash}\) be a hash function. Let \( \mathcal{A} \) be an adversary. We define \( \text{CR}_{\text{adv}}[\mathcal{A}, \text{Hash}] \) to be the advantage of \( \mathcal{A} \) in breaking the collision resistance of \(\text{Hash}\). This is defined as the probability that \( \mathcal{A} \) wins the following game:

\begin{itemize}
    \item \( \mathcal{A} \) outputs two distinct messages \( m \) and \( m' \).
\begin{itemize}
    \item We say \( \mathcal{A} \) wins the game if \( \text{Hash}(m) = \text{Hash}(m') \) but \( m \neq m' \).
\end{itemize}

Note that the probability of winning in this game is taken over the random choices of \( \mathcal{A} \) as well as any random choices made in generating system parameters that define \(\text{Hash}\).
\end{definition}

Now, let's analyse the security. \\
In EC-GGM model, the generator $\mathcal{G}$ is encoded as $\pi(1)$ and the public key $pk$ is encoded as $\pi(sk)$ for $sk \xleftarrow{\$}\mathbb{Z}_q$. We assume that $sk\neq 0$. These encodings of $\mathcal{G}$ and $pk$ are given to the adversary at the start of the signing attack game.
The adversary then interacts makes a sequence of queries to both the group and signing
oracles. The signing oracle on a message $m$ itself works as usual, computing h=Hash(m) but uses the group encoding $x = c\cdot \mathcal{G}$.

Note that we have $C = y'(x)^{-1}(h\cdot\mathcal{G} + pk\cdot x)$.
Here, $(x,y'(x))$ is the signature. For simplicity, , let us assume that x is output by the signing
oracle as well.
At the end of the signing attack game, the adversary outputs a forgery $(x^*,y'(x)^*)$ on a
message $m^*$
. The signature is then verified using the verification algorithm, computing $C = y'(x)^{*-1}(h^*\cdot\mathcal{G} + pk\cdot x^*)$.\\
Define:
\newcommand{\RN}[1]{%
  \textup{\uppercase\expandafter{\romannumeral#1}}%
}

\begin{itemize}
    \item \textbf{Type \RN{1} Forger.} $C^* = \pm C$ for some C computed by the signing oracle.
    \item \textbf{Type \RN{2} Forger.} $C^* \neq \pm C$ for any C computed by the signing oracle and $h^* \neq 0$.
    \item \textbf{Type \RN{3} Forger.} Neither Type \RN{1} or Type \RN{2}.
\end{itemize}

\textbf{Lazy simulation of the signature attack game.}
Instead of choosing the encoding function $\pi$ at random at the beginning of the attack game,
we can lazily construct $\pi$ a bit at a time. Represent $\pi$ as a set of pairs $(i, \mathcal{P})$ which grows over time so that $(i, \mathcal{P})$ represents the relation $\pi(i) = \mathcal{P}$.

At the end of the forgery, the adversary will output forgery $(x^*,y'(x)^*)$ on a message $m^*$. Verification routine will be used to verify this signature and verify will make $O(log \ q)$ group oracle queries as it uses add queries for computation. Total number of queries made by the adversary $N = N_{grp}+N_{sign}$ where $N_{grp}$ are the total number of group oracle queries explicitly made by the adversary (This includes group oracle queries for verification, generation of $\mathcal{G}, pk$)and $N_{sign}$ are the total number of signing queries.
The advantage of any adversary in the signature attack game using this lazy simulation of the group oracle is identical to that using the group oracle as originally defined.

\fbox{
  \begin{minipage}[t][20cm]{0.45\textwidth}
    \begin{minipage}[t][8cm]{\textwidth}
    \item \textbf{Initialization:}
    \begin{itemize}
        \item $\pi \gets \{(0, \mathcal{O})\}$. $sk \gets\mathbb{Z}_q^*$
        \item Invoke \text{(map, 1)} to obtain $\mathcal{G}$ and \text{(map, sk)} to obtain $pk$
        \item return $(\mathcal{G}, pk)$
    \end{itemize}
    \end{minipage}
    \begin{minipage}[t][12cm]{\textwidth}
    \item \textbf{To process a group oracle query \text{(map, i):}}
    \begin{itemize}
        \item If $i \notin \text{Domain}(\pi)$:
        \begin{itemize}
            \item $\mathcal{P} \xleftarrow{\$} E^*$. While $\mathcal{P} \in \text{Range}(\pi)$, do $\mathcal{P} \xleftarrow{\$} E^*$
            \item add $(-i, -\mathcal{P})$ and $(i, \mathcal{P})$ to $\pi$
        \end{itemize}
        \item return $\pi(i)$
    \end{itemize}
    \end{minipage}
  \end{minipage}
}
\fbox{
  \begin{minipage}[t][20cm]{0.45\textwidth}
    \begin{minipage}[t][8cm]{\textwidth}
     \item \textbf{To process a group oracle query \text{(add, $\mathcal{P}_1, \mathcal{P}_2$):}}
    \begin{itemize}
        \item \text{For} $j = 1, 2$, if $\mathcal{P}_j \notin \text{Range}(\pi)$
        \begin{itemize}
                \item $i  \xleftarrow{\$} \mathbb{Z}_q^*$. while $i \in \text{Domain}(\pi)$ do, $i  \xleftarrow{\$} \mathbb{Z}_q^*$
                \item add $(-i, -\mathcal{P}_j)$ and $(i, \mathcal{P}_j)$ to $\pi$
        \end{itemize}
        \item Invoke \text{(map, $\pi^{-1}(\mathcal{P}_1) + \pi^{-1}(\mathcal{P}_2)$)} and return the result
    \end{itemize}
    \end{minipage}
    \begin{minipage}[t][12cm]{\textwidth}

    \item \textbf{To process a request to sign $m$:}
    \begin{itemize}
        \item $h \gets \text{Hash}(m) \in Z_q$
        \item $c  \xleftarrow{\$} \mathbb{Z}_q^*$
        \item Invoke \text{(map, c)} to get $C$
        \item $x = [C]_x \in \mathbb{Z}_q$
        \item If $x=0$, return fail.
        \item If $(h + sk\cdot x) =0$, return fail.
        \item $y(x) = (h + sk\cdot x)$ and $y'(x) = c^{-1}*y(x)$
        \item \textbf{return} $(C, x, y'(x))$
    \end{itemize}


    \end{minipage}
  \end{minipage}
}


\hspace{0cm}
Lazy-Sim: Lazy simulation of ECDSA.

\newpage
\textbf{A symbolic simulation of the signature attack game}
The essential difference in this
game is that Domain($\pi$) will now consist of polynomials of the form $a + b\cdot D$, where $a, b \in \mathbb{Z})_q$
and $D$ is an indeterminant. Here, $D$ symbolically represents the value of $sk$. Note that $\pi$ will
otherwise still satisfy all of the requirements of an encoding function.


\fbox{
  \begin{minipage}[t][22cm]{0.45\textwidth}
    \begin{minipage}[t][10cm]{\textwidth}
    \item \textbf{Initialization:}
    \begin{itemize}
        \item $\pi \gets \{(0, \mathcal{O})\}$.
        \item Invoke \text{(map, 1)} to obtain $\mathcal{G}$ and \text{(map, D)} to obtain $pk$
        \item return $(\mathcal{G}, pk)$
    \end{itemize}
    \end{minipage}
    \begin{minipage}[t][12cm]{\textwidth}
    \item \textbf{To process a group oracle query \text{(map, i):}}
    \begin{itemize}
        \item If $i \notin \text{Domain}(\pi)$:
        \begin{itemize}
            \item $\mathcal{P} \xleftarrow{\$} E^*$. If $\mathcal{P} \in \text{Range}(\pi)$,abort.
            \item add $(-i, -\mathcal{P})$ and $(i, \mathcal{P})$ to $\pi$
        \end{itemize}
        \item return $\pi(i)$
    \end{itemize}
    \end{minipage}
  \end{minipage}
}
\fbox{
  \begin{minipage}[t][22cm]{0.45\textwidth}
    \begin{minipage}[t][8cm]{\textwidth}
     \item \textbf{To process a group oracle query \text{(add, $\mathcal{P}_1, \mathcal{P}_2$):}}
    \begin{itemize}
        \item \text{For} $j = 1, 2$, if $\mathcal{P}_j \notin \text{Range}(\pi)$
        \begin{itemize}
                \item $i  \xleftarrow{\$} \mathbb{Z}_q^*$. If  $i \in \text{Domain}(\pi)$, abort.
                \item add $(-i, -\mathcal{P}_j)$ and $(i, \mathcal{P}_j)$ to $\pi$
        \end{itemize}
        \item Invoke \text{(map, $\pi^{-1}(\mathcal{P}_1) + \pi^{-1}(\mathcal{P}_2)$)} and return the result
    \end{itemize}
    \end{minipage}
    \begin{minipage}[t][14cm]{\textwidth}

    \item \textbf{To process a request to sign $m$:}
    \begin{itemize}
        \item $h \gets \text{Hash}(m) \in \mathbb{Z}_q$
        \item $C  \xleftarrow{\$} E^*$
        \item If $C \in$ Range$(\pi)$ then abort.
        \item $x = [C]_x \in \mathbb{Z}_q$
        \item If $x=0$, return fail.
        \item If $(h + sk\cdot x) =0$, return fail.
        \item $y'(x) \xleftarrow{\$} \mathbb{Z}_q$
        \item $c = y'(x)^{-1}(h + D\cdot x)$
        \item If $c \in $ Domain($\pi$) then abort.
        \item add $(-c, -C)$ and $(c, C)$ to $\pi$
        \item \textbf{return} $(C, y'(x), x)$
    \end{itemize}


    \end{minipage}
  \end{minipage}
}


\hspace{0cm}
Symbolic-Sim: Symbolic simulation of ECDSA.

Analysis of security of ECDSA in the EC-GGM.  We assume here that the attack
is taking place with respect to the symbolic simulator.\\
\textbf{Type \RN{1} Forger.}
By definition of this forger, it produces - $C^* = \pm C$ for some C computed by the signing oracle. This means -
$y'(x^*)^{*-1}(h^* + D\cdot x^*) = \pm y'(x)^{-1}(h + D\cdot x)$
and $x\neq 0$.
When $\eta = \pm1, $ we have: $y'(x^*)^{*-1}(h^* + D\cdot x^*) = \eta \cdot y'(x)^{-1}(h + D\cdot x)$ which gives us two equations : $y'(x^*)^{*-1}h^* = \eta y'(x)^{-1}h$ and $y'(x^*)^{*-1}x^* = \eta y'(x)^{-1}x$. These imply that $h^* =h$ which means there is a collision in the Hash function.
\\Hence, we have shown that if we have an adversary $\mathcal{A}$ that produces forgery Type \RN{1} with probability $\epsilon_1$, then there exists another adversary  $\mathcal{A}'$ such that $CR_{adv}[\mathcal{A}', \text{Hash}] \geq \epsilon_1$.

\textbf{Type \RN{2} Forger.} $C^* \neq \pm C$ for any C computed by the signing oracle and $h^* \neq 0$. We have $\pi^{-1}(C^*) = a+bD$ and by verification, we have - $\pi^{-1}(C^*) = y'(x^*)^{*-1}(h^* + D\cdot x^*)$. Thus, we have $a=y'(x^*)^{*-1}h^*$ and $b=y'(x)^{-1}x$. Along with the condition that $h\neq 0$, we have $x^* = h^*a^{-1}b$. Since $b\neq 0$, $C^*$ must have been generated at random by some group oracle query
made directly by the adversary and since a,b were already determined before this query, $C^*$ is independent of these coefficients.

We want to use this {Type \RN{2} Forger.} to break the random-preimage resistance of Hash.
We first generate h, $h^{\dagger} \xleftarrow{\$} \mathbb{Z}_q$ and we want to find the pre-image of $h^\dagger$ in Hash. To do
this, we will guess the group oracle query that will produce the value $C^*$
in the forgery,
and then we will run our sampling algorithm to compute - $x^\dagger = h^\dagger a^{-1}b$ and if the adversary forges a signature, we succeed in finding a preimage of h.


$C^\dagger \xleftarrow{\$}$ Samp($x^\dagger)$.

If this sampler fails, we abort. Else, we will have $C^* = C^\dagger$ and $x^* = x^\dagger$

Hence, If \( \mathcal{A} \) is an efficient adversary that makes at most \( N \) signing or group queries, and which produces a Type II forgery with probability \( \epsilon_2 \), then there is an efficient adversary \( \mathcal{A}'' \) such that $\text{RPR}_{\text{adv}}[\mathcal{A}'', \text{Hash}] \geq (0.25+o(1))/N \cdot \epsilon_2$\\

\textbf{Type \RN{3} Forger.} This produces a forgery with $h^*=0$. This can be ruled out by assuming that it is hard to find a preimage of 0 under Hash.
\\Hence, we have shown that if we have an adversary $\mathcal{A}$ that produces forgery Type \RN{3} with probability $\epsilon_3$, then there exists another adversary  $\mathcal{A}'''$ such that $ZPR_{adv}[\mathcal{A}''', \text{Hash}] \geq \epsilon_3$.

\end{theorem}

\begin{theorem}
    Let $\mathcal{A}$ be an adversary attacking ECDSA that makes atmost $N$ signing or group queries. Then there exists adversaries $\mathcal{A}'$, $\mathcal{A}'$, $\mathcal{A}'''$ such that - \\
    $\text{CMA}^{ggm}_{adv}[\mathcal{A}, \text{ECDSA}] \leq \text{CR}_{adv}[\mathcal{A}', Hash] + \text{RPR}_{adv}[\mathcal{A}'', Hash](N \cdot (0.25+o(1))) + \text{ZPR}_{adv}[\mathcal{A}''', Hash] + O(N^2/q).
    $
    \begin{proof}
    Applying the proofs from the previous section, we get - \\
    $\text{CMA}^{ggm}_{adv}[\mathcal{A}, \text{ECDSA}] \leq \epsilon_1+ \epsilon_2 + \epsilon_3 + O(N^2/q).
    $\\
        Note: The difference between the adversaryâ€™s forging advantage in the Lazy-Sim and
Symbolic-Sim games is $O(N^2/q)$.
    \end{proof}
\end{theorem}

    Through the above proofs, we have shown that ECDSA is secure against uf-koa in ROM and has strong unforgeability in EC-GGM.
    \end{proof}
\end{theorem}
\end{itemize}


\end{definition}